## rCore-Lab-7 同步互斥

> 赵成钢 计75班 2017011362

#### 要求一：把框架填充完全
- 要填充的地方有两处，一个是`obtain_lock`，另一个是`drop`。

- 对于上锁这件事情，直接用一个循环不断询问锁的情况即可，如果被锁上了就放出时间片资源：

  ```rust
  fn obtain_lock(&self) {
    unsafe {
      loop {
        if !(*self.lock.get()) {
          *self.lock.get() = true;
          break;
        } else {
          yield_now();
        }
      }
    }
  }
  ```

- 解锁则直接把锁改成`false`：

  ```rust
  fn drop(&mut self) {
  	*self.lock = false;
  }
  ```

#### 要求二：为什么引入`MutexGuard`？

- 因为在`MutexGuard`析构（`drop`函数）的时候可以同时把里面的锁打开，个人认为这里是为了编程的方便，在守护变量离开作用域的时候自动放锁。
- 同时`deref`和`deref_mut`等封装也是一种对“不安全行为”的安全封装，可以方便外部的使用。

#### 要求三：为什么要修改`yield_now`并增加`park`

- 之前的`yield_now`会把当前线程的状态设置为`Sleeping`，如果没有唤醒，调度器是不会让它再次运行的。
- 现在的`yield_now`可以理解为放弃了目前的时间片，下次调度器调度时会再次把线程唤醒。
- 而对于`park`，在`yield_now`的同时把状态设置为`Sleeping`，是用来实现真的睡眠的。
- 而且改完了之后，我们就可以在`obtain_lock`中使用这个放弃时间片的操作，而不是只能调用`sleep`，这样会浪费很多睡眠的时间不能第一时间得到锁（因为最少睡1秒）
- 如果我们在`obtain_lock`里面用原来的那个`yield_now`的实现，这个线程将一觉不醒。

#### 要求四：为什么要加入一瞬间的中断处理

- 为了响应时钟中断，并触发`tick`函数，之后在函数中进一步提醒计时器唤醒线程。
- 如果不加入这一步，在同时有运行中和睡眠的线程的同时，睡眠的线程将永远不会被唤醒。

#### 要求五：为什么需要修改`spie`？

- 把`spie`置为`false`意味着在内核线程运行的时候不会响应异步中断，这样意味着不会有自动的线程调度，或者说不会自动打断线程的执行。
- 其实这里和第一个编程任务我觉得是呼应的，在第一个任务中，我并没有用到原子操作，而把`spie`置为`false`正好可以代替原子操作，不会有两个线程同时拿到一个锁的情况。