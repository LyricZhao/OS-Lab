## rCore-Lab-5 用户进程（+虚拟内存管理+线程管理）

> 赵成钢 计75班 2017011362

#### 要求一：阅读理解文档第八章
#### 要求二：为rCore增加`sys_fork`

- 具体代码见目录中，下面阐释一下整个流程
- 首先回答一下实验指导中的问题：
  - 如何控制子进程的返回值？（这里我理解的问题是`fork`函数的返回值，整个进程的返回值就直接返回就完事了，没有特殊）
    - 对于`fork()`函数，父进程返回子进程`id`，子进程应该返回0
    - 这里因为父进程是用系统调用来的（走了异常的机制），所以我们直接把`TrapFrame`里面的返回值（`x[10]`）改成0就行了
  - 目前尚未实现进程切分，是否可以偷懒把线程当进程用？
    - 可以，我认为这里本质是rCore写到这里，其实线程和进程还是一个概念，如果做了进一步的进程的工作应该会有区别
  - 如何复制线程？
    - 复制一份上下文
    - 一份系统调用时的异常帧
    - 把整个页表在虚拟地址保持不变的情况下，把对应的物理页复制一遍
      - 如何是`ByLinear`映射的部分（Kernel）不需要复制，因为用户本身也不可以写
      - 如果是`ByFrame`管理的部分，需要完全复制一遍
- 有了上面的思路，总结一下就是：
  - 新申请一个内核栈
  - 新申请一个`MemorySet`，把原来的`MemorySet`按照上述方法复制一遍
    - 区域信息复制
    - 区域虚拟地址保持不变的情况下，对应物理页复制（Kernel不复制）
    - 同时会产生一个新的页表
    - 构造对应的上下文
      - `ra`：异常返回地址（本身系统调用就是异常）
      - `satp`：新的页表
      - `s[0-11]`：全是0，因为编译器已经保存了caller-saved寄存器，callee-saved寄存器也不会在调用前使用
      - `tf`：系统调用时的异常帧
    - 构造完成后压到内核栈中
      - 下一次调度器执行线程切换的时候就会从栈中读取这些信息初始化fork出来的线程为运行`sys_fork()`之后的状态
  - 把新的线程加入调度器

